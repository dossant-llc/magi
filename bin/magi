#!/usr/bin/env node

const path = require('path');
const { execSync, spawn } = require('child_process');

// Auto-detect project root from magi command location
const projectRoot = path.resolve(__dirname, '..');
process.env.MAGI_ROOT = projectRoot;

const colors = {
  prompt: '\x1b[36m',
  success: '\x1b[92m',
  system: '\x1b[33m',
  error: '\x1b[31m',
  hint: '\x1b[90m',
  info: '\x1b[36m',
  warning: '\x1b[33m',
  reset: '\x1b[0m'
};

// Handle basic flags
const args = process.argv.slice(2);
const command = args[0];

if (args.includes('--version') || args.includes('-v')) {
  const pkg = require('../package.json');
  console.log(pkg.version);
  process.exit(0);
}

if (args.includes('--help') || args.includes('-h')) {
  console.log('üßô Magi - Your Personal AI Memory Bank');
  console.log('');
  console.log('Usage: magi [command] [options]');
  console.log('');
  console.log('Commands:');
  console.log('  start     Start BrainBridge service and stream logs');
  console.log('            Options: --dev (development mode with explicit file watching)');
  console.log('  stop      Stop BrainBridge service');
  console.log('  restart   Restart BrainBridge service (preserves --dev flag)');
  console.log('  status    Show system status and diagnostics');
  console.log('  logs      Stream BrainBridge logs (if running)');
  console.log('  register  Setup Brain Proxy for ChatGPT integration');
  console.log('            Options: --local (use localhost instead of production server)');
  console.log('  index     Build vector index for AI search');
  console.log('            Options: --force (rebuild all)');
  console.log('  install   Install integrations');
  console.log('    claude  Install Claude Code MCP server');
  console.log('  remove    Remove integrations');
  console.log('    claude  Remove Claude Code MCP server');
  console.log('');
  console.log('Options:');
  console.log('  --version, -v    Show version');
  console.log('  --help, -h       Show help');
  console.log('  --dev            Development mode (file watching enabled)');
  console.log('');
  console.log('Examples:');
  console.log('  magi start       # Start service (file watching always enabled)');
  console.log('  magi start --dev # Development mode (explicit file watching)');
  console.log('  magi             # Show logs (if running) or prompt to start');
  process.exit(0);
}

// Check if BrainBridge is running
function isBrainBridgeRunning() {
  try {
    const processes = execSync('ps aux | grep "tsx.*server.ts.*stdio" | grep -v grep', { encoding: 'utf8' }).trim();
    return processes.length > 0;
  } catch (e) {
    return false;
  }
}

// Handle subcommands
switch (command) {
  case 'start':
    // Check for --dev flag
    const hasDevFlag = args.includes('--dev');
    
    // Start BrainBridge service with logs
    const startScript = require.resolve('../dev/scripts/magi-start.js');
    const scriptArgs = hasDevFlag ? ['--dev'] : [];
    
    if (hasDevFlag) {
      console.log(`${colors.info}üîß Starting in development mode (verbose logging enabled)${colors.reset}`);
    }
    spawn('node', [startScript, ...scriptArgs], { stdio: 'inherit' });
    break;
    
  case 'stop':
    console.log(`${colors.system}üõë Stopping BrainBridge service...${colors.reset}`);
    try {
      execSync('pkill -f "brainbridge.*stdio"', { stdio: 'inherit' });
      console.log(`${colors.success}‚úÖ BrainBridge stopped${colors.reset}`);
    } catch (error) {
      console.log(`${colors.warning}‚ö†Ô∏è No BrainBridge processes found${colors.reset}`);
    }
    break;
    
  case 'restart':
    console.log(`${colors.system}üîÑ Restarting BrainBridge service...${colors.reset}`);
    try {
      // Stop existing processes
      execSync('pkill -f "brainbridge.*stdio"', { stdio: 'pipe' });
      console.log(`${colors.hint}Stopped existing processes${colors.reset}`);
    } catch (error) {
      // No existing processes, that's fine
    }
    
    // Remove any stale lock file
    const projectRoot = path.resolve(__dirname, '..');
    const lockFile = path.join(projectRoot, '.magi-start.lock');
    try {
      if (require('fs').existsSync(lockFile)) {
        require('fs').unlinkSync(lockFile);
        console.log(`${colors.hint}Removed stale lock file${colors.reset}`);
      }
    } catch (e) {
      // Ignore cleanup errors
    }
    
    // Start new instance with same args (preserve --dev flag if present)
    const restartArgs = process.argv.slice(2).filter(arg => arg !== 'restart');
    restartArgs.unshift('start');
    
    console.log(`${colors.info}Starting fresh instance...${colors.reset}`);
    spawn('node', [__filename, ...restartArgs], { stdio: 'inherit' });
    break;
    
  case 'status':
    // Show enhanced status
    try {
      execSync('npm run diag', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
    } catch (error) {
      console.log(`${colors.error}‚ùå Status check failed${colors.reset}`);
    }
    break;
    
  case 'logs':
    // Show logs if running
    if (isBrainBridgeRunning()) {
      console.log(`${colors.info}üìú Streaming BrainBridge logs...${colors.reset}`);
      try {
        spawn('node', [path.join(__dirname, '../dev/scripts/chat-simple.js'), 'logs'], { stdio: 'inherit' });
      } catch (error) {
        console.log(`${colors.error}‚ùå Failed to stream logs: ${error.message}${colors.reset}`);
      }
    } else {
      console.log(`${colors.warning}‚ö†Ô∏è BrainBridge is not running${colors.reset}`);
      console.log(`${colors.hint}üí° Start it with: magi start${colors.reset}`);
    }
    break;
    
  case 'index':
    // Run indexing
    let profile = 'default';
    let forceRebuild = false;
    
    // Parse arguments: magi index [profile] [--force]
    for (let i = 1; i < args.length; i++) {
      if (args[i] === '--force' || args[i] === '-f') {
        forceRebuild = true;
      } else if (!args[i].startsWith('-')) {
        profile = args[i];
      }
    }
    
    const location = process.env.MEMORIES_LOCATION || 'project';
    const memoriesPath = process.env.MEMORIES_DIR || 
      (location === 'documents' 
        ? path.join(require('os').homedir(), 'Documents', 'memories', 'profiles', profile)
        : path.join(path.join(__dirname, '..'), 'data', 'memories', 'profiles', profile));
    
    console.log(`${colors.info}üß† Building vector index for profile: ${colors.success}${profile}${colors.reset}`);
    console.log(`${colors.hint}üìÅ Indexing memories from: ${memoriesPath}${colors.reset}`);
    console.log(`${colors.hint}üíæ Index will be stored at: ${path.join(memoriesPath, 'embeddings')}${colors.reset}`);
    
    if (forceRebuild) {
      console.log(`${colors.warning}üîÑ Force rebuild enabled - will reprocess all files${colors.reset}`);
    }
    
    try {
      const startTime = Date.now();
      
      if (forceRebuild) {
        execSync('npm run magic --workspace=services/brainbridge -- index --force', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
      } else {
        execSync('npm run magic --workspace=services/brainbridge -- index', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
      }
      
      const endTime = Date.now();
      const elapsedMs = endTime - startTime;
      const elapsedSec = Math.round(elapsedMs / 1000);
      const elapsedMin = Math.floor(elapsedSec / 60);
      const remainingSec = elapsedSec % 60;
      
      let timeString;
      if (elapsedMin > 0) {
        timeString = `${elapsedMin}m ${remainingSec}s`;
      } else {
        timeString = `${elapsedSec}s`;
      }
      
      console.log(`${colors.success}‚úÖ Indexing complete for profile: ${profile}${colors.reset}`);
      console.log(`${colors.hint}‚è±Ô∏è  Total time: ${timeString}${colors.reset}`);
    } catch (error) {
      console.log(`${colors.error}‚ùå Indexing failed${colors.reset}`);
      process.exit(1);
    }
    break;

  case 'install':
    const installTarget = args[1];
    if (installTarget === 'claude') {
      console.log(`${colors.info}üîß Installing Claude Code MCP server...${colors.reset}`);
      try {
        // First try to remove existing server if it exists
        try {
          execSync('claude mcp remove magi', { stdio: 'pipe' });
          console.log(`${colors.hint}Removed existing MCP server configuration${colors.reset}`);
        } catch {
          // Server doesn't exist, that's fine
        }
        
        const projectRoot = '/Users/igor/Documents/code/agiforme';
        // Use the lean stdio mode with cd to ensure proper module resolution
        const mcpCommand = `claude mcp add --scope user magi --env PROJECT_FOLDER=${projectRoot} -- sh -c "cd ${projectRoot} && npm run magi:mcp"`;
        console.log(`${colors.hint}Running lean stdio MCP server setup...${colors.reset}`);
        execSync(mcpCommand, { stdio: 'inherit' });
        console.log(`${colors.success}‚úÖ Claude Code MCP server installed (lean stdio mode)${colors.reset}`);
        console.log(`${colors.hint}üí° Server 'magi' is now available globally in Claude Code${colors.reset}`);
        console.log(`${colors.hint}üìù No HTTP server or port 8147 registration - pure stdio communication${colors.reset}`);
      } catch (error) {
        console.log(`${colors.error}‚ùå Failed to install Claude Code MCP server${colors.reset}`);
        console.log(`${colors.hint}üí° Make sure 'claude' command is available and 'tsx' is installed globally${colors.reset}`);
        process.exit(1);
      }
    } else {
      console.log(`${colors.error}‚ùå Unknown install target: ${installTarget}${colors.reset}`);
      console.log(`${colors.hint}üí° Available targets: claude${colors.reset}`);
      process.exit(1);
    }
    break;

  case 'remove':
    const removeTarget = args[1];
    if (removeTarget === 'claude') {
      console.log(`${colors.info}üîß Removing Claude Code MCP server...${colors.reset}`);
      try {
        execSync('claude mcp remove magi', { stdio: 'inherit' });
        console.log(`${colors.success}‚úÖ Claude Code MCP server removed successfully${colors.reset}`);
      } catch (error) {
        console.log(`${colors.error}‚ùå Failed to remove Claude Code MCP server${colors.reset}`);
        console.log(`${colors.hint}üí° Server may not be installed or 'claude' command is unavailable${colors.reset}`);
        process.exit(1);
      }
    } else {
      console.log(`${colors.error}‚ùå Unknown remove target: ${removeTarget}${colors.reset}`);
      console.log(`${colors.hint}üí° Available targets: claude${colors.reset}`);
      process.exit(1);
    }
    break;
    
  case 'register':
    // Brain Proxy registration
    console.log(`${colors.info}üßô mAgi Brain Proxy Registration${colors.reset}`);
    console.log(`${colors.hint}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
    console.log('');
    
    try {
      const crypto = require('crypto');
      const os = require('os');
      const fs = require('fs');
      
      // Generate credentials
      console.log(`${colors.system}Generating secure credentials...${colors.reset}`);
      
      // Create route: initials + 8 char hex (e.g., ig-4f2a8b9d)
      const initials = os.userInfo().username.substring(0, 2).toLowerCase();
      const routeSuffix = crypto.randomBytes(4).toString('hex');
      const route = `${initials}-${routeSuffix}`;
      
      // Create secret: 32 char hex
      const secret = crypto.randomBytes(16).toString('hex');
      
      console.log(`${colors.success}‚úÖ Route: ${colors.prompt}${route}${colors.reset}`);
      console.log(`${colors.success}‚úÖ Secret: ${colors.prompt}${secret}${colors.reset}`);
      console.log('');
      
      // Determine proxy URL (production vs development)
      const proxyUrl = args.includes('--local') 
        ? 'wss://localhost:9025/bp/connect'
        : 'wss://hub.m.agifor.me:9025/bp/connect';
      
      const openApiUrl = args.includes('--local')
        ? 'https://localhost:9025/bp/openapi.json'  
        : 'https://hub.m.agifor.me/bp/openapi.json';
      
      // Test connection to Brain Proxy
      console.log(`${colors.system}Testing connection to BrainCloud...${colors.reset}`);
      
      const WebSocket = require('ws');
      const testUrl = `${proxyUrl}?route=${encodeURIComponent(route)}&token=${encodeURIComponent(secret)}`;
      
      const ws = new WebSocket(testUrl);
      let connectionTestComplete = false;
      
      // Set a timeout for the connection test
      const testTimeout = setTimeout(() => {
        if (!connectionTestComplete) {
          connectionTestComplete = true;
          console.log(`${colors.warning}‚ö†Ô∏è Connection test timed out (proxy may be offline)${colors.reset}`);
          ws.terminate();
          showConfiguration();
        }
      }, 10000); // 10 second timeout
      
      ws.on('open', () => {
        if (!connectionTestComplete) {
          connectionTestComplete = true;
          clearTimeout(testTimeout);
          console.log(`${colors.success}‚úÖ Connected to ${proxyUrl}${colors.reset}`);
          ws.close(1000, 'Registration test complete');
          showConfiguration();
        }
      });
      
      ws.on('error', (error) => {
        if (!connectionTestComplete) {
          connectionTestComplete = true;
          clearTimeout(testTimeout);
          console.log(`${colors.warning}‚ö†Ô∏è Connection failed: ${error.message}${colors.reset}`);
          console.log(`${colors.hint}üí° This may be normal if BrainCloud is offline${colors.reset}`);
          showConfiguration();
        }
      });
      
      function showConfiguration() {
        console.log('');
        console.log(`${colors.info}üìù Add these to your .env file:${colors.reset}`);
        console.log(`${colors.hint}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${colors.reset}`);
        console.log(`BRAIN_PROXY_ENABLED=true`);
        console.log(`BRAIN_PROXY_URL=${proxyUrl}`);
        console.log(`BRAIN_PROXY_ROUTE=${route}`);
        console.log(`BRAIN_PROXY_SECRET=${secret}`);
        console.log(`BRAIN_PROXY_LOCAL_MCP_URL=http://localhost:8147/mcp`);
        console.log(`${colors.hint}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${colors.reset}`);
        console.log('');
        
        console.log(`${colors.hint}üí° Quick setup:${colors.reset}`);
        const envPath = path.join(__dirname, '..', 'services', 'brainbridge', '.env');
        console.log(`   ${colors.prompt}echo '' >> ${envPath}${colors.reset}`);
        console.log(`   ${colors.prompt}echo '# Brain Proxy Configuration' >> ${envPath}${colors.reset}`);
        console.log(`   ${colors.prompt}echo 'BRAIN_PROXY_ENABLED=true' >> ${envPath}${colors.reset}`);
        console.log(`   ${colors.prompt}echo 'BRAIN_PROXY_URL=${proxyUrl}' >> ${envPath}${colors.reset}`);
        console.log(`   ${colors.prompt}echo 'BRAIN_PROXY_ROUTE=${route}' >> ${envPath}${colors.reset}`);
        console.log(`   ${colors.prompt}echo 'BRAIN_PROXY_SECRET=${secret}' >> ${envPath}${colors.reset}`);
        console.log(`   ${colors.prompt}echo 'BRAIN_PROXY_LOCAL_MCP_URL=http://localhost:8147/mcp' >> ${envPath}${colors.reset}`);
        console.log('');
        
        console.log(`${colors.success}To connect ChatGPT:${colors.reset}`);
        console.log(`1. Go to ChatGPT ‚Üí Create GPT ‚Üí Configure`);
        console.log(`2. Add action with URL: ${colors.prompt}${openApiUrl}${colors.reset}`);
        console.log(`3. Add authentication: ${colors.prompt}Bearer ${secret}${colors.reset} (or legacy header X-Brain-Key: ${secret})`);
        console.log(`4. Save and test with "${colors.prompt}magi status${colors.reset}"`);
        console.log('');
        console.log(`${colors.hint}üí° Restart BrainBridge after updating .env: ${colors.prompt}magi restart${colors.reset}`);
      }
      
    } catch (error) {
      console.log(`${colors.error}‚ùå Registration failed: ${error.message}${colors.reset}`);
      console.log(`${colors.hint}üí° Make sure Node.js crypto module is available${colors.reset}`);
      process.exit(1);
    }
    break;
    
  default:
    // Default behavior: Launch interactive REPL
    console.log(`${colors.info}üßô Launching MAGI Interactive Mode...${colors.reset}`);
    const replScript = path.join(__dirname, '../dev/scripts/magi-repl.js');
    
    try {
      spawn('node', [replScript], { stdio: 'inherit' });
    } catch (error) {
      console.log(`${colors.error}‚ùå Failed to start REPL: ${error.message}${colors.reset}`);
      
      // Fallback to old behavior  
      if (isBrainBridgeRunning()) {
        console.log(`${colors.success}üßô BrainBridge is running${colors.reset}`);
        console.log(`${colors.hint}üí° Commands: ${colors.prompt}magi logs${colors.reset} ${colors.hint}(stream logs) | ${colors.prompt}magi status${colors.reset} ${colors.hint}(full status)${colors.reset}`);
      } else {
        console.log(`${colors.warning}üßô BrainBridge is down${colors.reset}`);
        console.log(`${colors.hint}üí° Start it with: ${colors.prompt}magi start${colors.reset} ${colors.hint}in another window${colors.reset}`);
        console.log(`${colors.hint}Or run: ${colors.prompt}magi status${colors.reset} ${colors.hint}to check system health${colors.reset}`);
      }
    }
    break;
}
#!/usr/bin/env node

const path = require('path');
const { execSync, spawn } = require('child_process');

// Auto-detect project root from magi command location
const projectRoot = path.resolve(__dirname, '..');
process.env.MAGI_ROOT = projectRoot;

const colors = {
  prompt: '\x1b[36m',
  success: '\x1b[92m',
  system: '\x1b[33m',
  error: '\x1b[31m',
  hint: '\x1b[90m',
  info: '\x1b[36m',
  warning: '\x1b[33m',
  reset: '\x1b[0m'
};

// Handle basic flags
const args = process.argv.slice(2);
const command = args[0];

if (args.includes('--version') || args.includes('-v')) {
  const pkg = require('../package.json');
  console.log(pkg.version);
  process.exit(0);
}

if (args.includes('--help') || args.includes('-h')) {
  console.log('üßô Magi - Your Personal AI Memory Bank');
  console.log('');
  console.log('Usage: magi [command] [options]');
  console.log('');
  console.log('Commands:');
  console.log('  start     Start BrainBridge service and stream logs');
  console.log('            Options: --dev (development mode with explicit file watching)');
  console.log('  stop      Stop BrainBridge service');
  console.log('  restart   Restart BrainBridge service (preserves --dev flag)');
  console.log('  status    Show system status and diagnostics');
  console.log('  logs      Stream BrainBridge logs (if running)');
  console.log('  register  Setup Brain Proxy for ChatGPT integration');
  console.log('            Options: --local (use localhost instead of production server)');
  console.log('                     --reset (regenerate existing credentials)');
  console.log('  index     Build vector index for AI search');
  console.log('            Options: --force (rebuild all)');
  console.log('  nap       Analyze and consolidate memories (v0.1.2 "Nap")');
  console.log('            Options: --deep (full analysis), status (show insights)');
  console.log('  install   Install integrations');
  console.log('    claude  Install Claude Code MCP server');
  console.log('  remove    Remove integrations');
  console.log('    claude  Remove Claude Code MCP server');
  console.log('');
  console.log('Options:');
  console.log('  --version, -v    Show version');
  console.log('  --help, -h       Show help');
  console.log('  --dev            Development mode (file watching enabled)');
  console.log('');
  console.log('Examples:');
  console.log('  magi start       # Start service (file watching always enabled)');
  console.log('  magi start --dev # Development mode (explicit file watching)');
  console.log('  magi             # Show logs (if running) or prompt to start');
  console.log('  magi nap         # Quick memory analysis and consolidation');
  console.log('  magi nap --deep  # Deep memory analysis with recommendations');
  console.log('  magi nap status  # Show memory health and conflicts');
  process.exit(0);
}

// Check if BrainBridge is running
function isBrainBridgeRunning() {
  try {
    // Look for the actual process: node dist/server.js in brainbridge directory
    const processes = execSync('ps aux | grep "node.*dist/server.js" | grep -v grep', { encoding: 'utf8' }).trim();
    return processes.length > 0;
  } catch (e) {
    return false;
  }
}

// Handle subcommands
switch (command) {
  case 'start':
    // Check for --dev flag
    const hasDevFlag = args.includes('--dev');
    
    // Start BrainBridge service with logs
    const startScript = require.resolve('../dev/scripts/magi-start.js');
    const scriptArgs = hasDevFlag ? ['--dev'] : [];
    
    if (hasDevFlag) {
      console.log(`${colors.info}üîß Starting in development mode (verbose logging enabled)${colors.reset}`);
    }
    spawn('node', [startScript, ...scriptArgs], { stdio: 'inherit' });
    break;
    
  case 'stop':
    console.log(`${colors.system}üõë Stopping BrainBridge service...${colors.reset}`);
    try {
      // Kill the actual process pattern: node dist/server.js
      execSync('pkill -f "node.*dist/server.js"', { stdio: 'inherit' });
      console.log(`${colors.success}‚úÖ BrainBridge stopped${colors.reset}`);
    } catch (error) {
      console.log(`${colors.warning}‚ö†Ô∏è No BrainBridge processes found${colors.reset}`);
    }
    break;
    
  case 'restart':
    console.log(`${colors.system}üîÑ Restarting BrainBridge service...${colors.reset}`);
    try {
      // Stop existing processes
      execSync('pkill -f "node.*dist/server.js"', { stdio: 'pipe' });
      console.log(`${colors.hint}Stopped existing processes${colors.reset}`);
    } catch (error) {
      // No existing processes, that's fine
    }
    
    // Remove any stale lock file
    const projectRoot = path.resolve(__dirname, '..');
    const lockFile = path.join(projectRoot, '.magi-start.lock');
    try {
      if (require('fs').existsSync(lockFile)) {
        require('fs').unlinkSync(lockFile);
        console.log(`${colors.hint}Removed stale lock file${colors.reset}`);
      }
    } catch (e) {
      // Ignore cleanup errors
    }
    
    // Start new instance with same args (preserve --dev flag if present)
    const restartArgs = process.argv.slice(2).filter(arg => arg !== 'restart');
    restartArgs.unshift('start');
    
    console.log(`${colors.info}Starting fresh instance...${colors.reset}`);
    spawn('node', [__filename, ...restartArgs], { stdio: 'inherit' });
    break;
    
  case 'status':
    // Show enhanced status
    try {
      execSync('npm run diag', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
    } catch (error) {
      console.log(`${colors.error}‚ùå Status check failed${colors.reset}`);
    }
    break;
    
  case 'logs':
    // Show logs if running
    if (isBrainBridgeRunning()) {
      console.log(`${colors.info}üìú Streaming BrainBridge logs...${colors.reset}`);
      try {
        spawn('node', [path.join(__dirname, '../dev/scripts/chat-simple.js'), 'logs'], { stdio: 'inherit' });
      } catch (error) {
        console.log(`${colors.error}‚ùå Failed to stream logs: ${error.message}${colors.reset}`);
      }
    } else {
      console.log(`${colors.warning}‚ö†Ô∏è BrainBridge is not running${colors.reset}`);
      console.log(`${colors.hint}üí° Start it with: magi start${colors.reset}`);
    }
    break;
    
  case 'index':
    // Run indexing
    let profile = 'default';
    let forceRebuild = false;
    
    // Parse arguments: magi index [profile] [--force]
    for (let i = 1; i < args.length; i++) {
      if (args[i] === '--force' || args[i] === '-f') {
        forceRebuild = true;
      } else if (!args[i].startsWith('-')) {
        profile = args[i];
      }
    }
    
    const location = process.env.MEMORIES_LOCATION || 'project';
    const memoriesPath = process.env.MEMORIES_DIR || 
      (location === 'documents' 
        ? path.join(require('os').homedir(), 'Documents', 'memories', 'profiles', profile)
        : path.join(path.join(__dirname, '..'), 'data', 'memories', 'profiles', profile));
    
    console.log(`${colors.info}üß† Building vector index for profile: ${colors.success}${profile}${colors.reset}`);
    console.log(`${colors.hint}üìÅ Indexing memories from: ${memoriesPath}${colors.reset}`);
    console.log(`${colors.hint}üíæ Index will be stored at: ${path.join(memoriesPath, 'embeddings')}${colors.reset}`);
    
    if (forceRebuild) {
      console.log(`${colors.warning}üîÑ Force rebuild enabled - will reprocess all files${colors.reset}`);
    }
    
    try {
      const startTime = Date.now();
      
      if (forceRebuild) {
        execSync('npm run magic --workspace=services/brainbridge -- index --force', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
      } else {
        execSync('npm run magic --workspace=services/brainbridge -- index', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
      }
      
      const endTime = Date.now();
      const elapsedMs = endTime - startTime;
      const elapsedSec = Math.round(elapsedMs / 1000);
      const elapsedMin = Math.floor(elapsedSec / 60);
      const remainingSec = elapsedSec % 60;
      
      let timeString;
      if (elapsedMin > 0) {
        timeString = `${elapsedMin}m ${remainingSec}s`;
      } else {
        timeString = `${elapsedSec}s`;
      }
      
      console.log(`${colors.success}‚úÖ Indexing complete for profile: ${profile}${colors.reset}`);
      console.log(`${colors.hint}‚è±Ô∏è  Total time: ${timeString}${colors.reset}`);
    } catch (error) {
      console.log(`${colors.error}‚ùå Indexing failed${colors.reset}`);
      process.exit(1);
    }
    break;

  case 'install':
    const installTarget = args[1];
    if (installTarget === 'claude') {
      console.log(`${colors.info}üîß Installing Claude Code MCP server...${colors.reset}`);
      try {
        // First try to remove existing server if it exists
        try {
          execSync('claude mcp remove magi', { stdio: 'pipe' });
          console.log(`${colors.hint}Removed existing MCP server configuration${colors.reset}`);
        } catch {
          // Server doesn't exist, that's fine
        }
        
        const projectRoot = '/Users/igor/Documents/code/agiforme';
        // Use the lean stdio mode with cd to ensure proper module resolution
        const mcpCommand = `claude mcp add --scope user magi --env PROJECT_FOLDER=${projectRoot} -- sh -c "cd ${projectRoot} && npm run magi:mcp"`;
        console.log(`${colors.hint}Running lean stdio MCP server setup...${colors.reset}`);
        execSync(mcpCommand, { stdio: 'inherit' });
        console.log(`${colors.success}‚úÖ Claude Code MCP server installed (lean stdio mode)${colors.reset}`);
        console.log(`${colors.hint}üí° Server 'magi' is now available globally in Claude Code${colors.reset}`);
        console.log(`${colors.hint}üìù No HTTP server or port 8147 registration - pure stdio communication${colors.reset}`);
      } catch (error) {
        console.log(`${colors.error}‚ùå Failed to install Claude Code MCP server${colors.reset}`);
        console.log(`${colors.hint}üí° Make sure 'claude' command is available and 'tsx' is installed globally${colors.reset}`);
        process.exit(1);
      }
    } else {
      console.log(`${colors.error}‚ùå Unknown install target: ${installTarget}${colors.reset}`);
      console.log(`${colors.hint}üí° Available targets: claude${colors.reset}`);
      process.exit(1);
    }
    break;

  case 'remove':
    const removeTarget = args[1];
    if (removeTarget === 'claude') {
      console.log(`${colors.info}üîß Removing Claude Code MCP server...${colors.reset}`);
      try {
        execSync('claude mcp remove magi', { stdio: 'inherit' });
        console.log(`${colors.success}‚úÖ Claude Code MCP server removed successfully${colors.reset}`);
      } catch (error) {
        console.log(`${colors.error}‚ùå Failed to remove Claude Code MCP server${colors.reset}`);
        console.log(`${colors.hint}üí° Server may not be installed or 'claude' command is unavailable${colors.reset}`);
        process.exit(1);
      }
    } else {
      console.log(`${colors.error}‚ùå Unknown remove target: ${removeTarget}${colors.reset}`);
      console.log(`${colors.hint}üí° Available targets: claude${colors.reset}`);
      process.exit(1);
    }
    break;

  case 'nap':
    // Memory analysis and consolidation
    const napSubcommand = args[1];
    const isDeepAnalysis = args.includes('--deep');

    if (napSubcommand === 'status') {
      console.log(`${colors.info}üß†üí§ Magi Memory Health Status${colors.reset}`);
      try {
        execSync('npm run magic --workspace=services/brainbridge -- nap status', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
      } catch (error) {
        console.log(`${colors.error}‚ùå Memory analysis failed${colors.reset}`);
      }
    } else {
      // Default nap behavior
      console.log(`${colors.info}üß†üí§ Magi is taking a nap to analyze memories...${colors.reset}`);

      if (isDeepAnalysis) {
        console.log(`${colors.info}üîç Running deep memory analysis (this may take a while)${colors.reset}`);
      } else {
        console.log(`${colors.info}‚ö° Running quick memory consolidation${colors.reset}`);
      }

      try {
        const startTime = Date.now();
        const napCommand = isDeepAnalysis ? 'nap --deep' : 'nap';

        execSync(`npm run magic --workspace=services/brainbridge -- ${napCommand}`, {
          stdio: 'inherit',
          cwd: path.join(__dirname, '..')
        });

        const endTime = Date.now();
        const elapsedSec = Math.round((endTime - startTime) / 1000);

        console.log(`${colors.success}‚úÖ Memory analysis complete${colors.reset}`);
        console.log(`${colors.hint}‚è±Ô∏è  Analysis time: ${elapsedSec}s${colors.reset}`);
        console.log(`${colors.hint}üí° Run '${colors.prompt}magi nap status${colors.reset}${colors.hint}' to see insights${colors.reset}`);
      } catch (error) {
        console.log(`${colors.error}‚ùå Memory analysis failed${colors.reset}`);
        process.exit(1);
      }
    }
    break;

  case 'register':
    // Brain Proxy registration
    console.log(`${colors.info}üßô mAgi Brain Proxy Registration${colors.reset}`);
    console.log(`${colors.hint}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${colors.reset}`);
    console.log('');
    
    try {
      const crypto = require('crypto');
      const os = require('os');
      const fs = require('fs');
      
      // Check for existing credentials in .env file (root project .env)
      const envPath = path.join(__dirname, '..', '.env');
      let route, secret;
      
      if (fs.existsSync(envPath)) {
        const envContent = fs.readFileSync(envPath, 'utf8');
        const routeMatch = envContent.match(/^BRAIN_PROXY_ROUTE=(.+)$/m);
        const secretMatch = envContent.match(/^BRAIN_PROXY_SECRET=(.+)$/m);
        
        if (routeMatch && secretMatch) {
          route = routeMatch[1];
          secret = secretMatch[1];
          console.log(`${colors.warning}‚ö†Ô∏è Existing credentials found in .env file${colors.reset}`);
          console.log(`${colors.hint}To regenerate credentials, delete the BRAIN_PROXY_* lines from:${colors.reset}`);
          console.log(`${colors.hint}   ${envPath}${colors.reset}`);
          console.log(`${colors.hint}Or use: ${colors.prompt}magi register --reset${colors.reset}`);
          console.log('');
        }
      }
      
      // Track if we're using existing credentials
      const usingExisting = !!(route && secret && !args.includes('--reset'));
      
      // Generate new credentials if none exist or --reset flag is used
      if (!usingExisting) {
        if (args.includes('--reset')) {
          console.log(`${colors.system}üîÑ Resetting credentials (--reset flag detected)...${colors.reset}`);
        } else {
          console.log(`${colors.system}Generating secure credentials...${colors.reset}`);
        }
        
        // Create route: initials + 8 char hex (e.g., ig-4f2a8b9d)
        const initials = os.userInfo().username.substring(0, 2).toLowerCase();
        const routeSuffix = crypto.randomBytes(4).toString('hex');
        route = `${initials}-${routeSuffix}`;
        
        // Create secret: 32 char hex
        secret = crypto.randomBytes(16).toString('hex');
        
        // Write new credentials to .env file
        console.log(`${colors.system}Writing credentials to .env file...${colors.reset}`);
        
        // Read existing .env content
        let envContent = '';
        if (fs.existsSync(envPath)) {
          envContent = fs.readFileSync(envPath, 'utf8');
          // Remove existing BRAIN_PROXY_* lines if doing a reset
          if (args.includes('--reset')) {
            envContent = envContent.split('\n')
              .filter(line => !line.startsWith('BRAIN_PROXY_'))
              .join('\n');
          }
        }
        
        // Determine proxy URL (production vs development)
        const proxyUrl = args.includes('--local') 
          ? 'wss://localhost:9025/bp/connect'
          : 'wss://hub.m.agifor.me:9025/bp/connect';
        
        // Append new configuration
        const newConfig = `
# Brain Proxy Configuration
BRAIN_PROXY_ENABLED=true
BRAIN_PROXY_URL=${proxyUrl}
BRAIN_PROXY_ROUTE=${route}
BRAIN_PROXY_SECRET=${secret}
BRAIN_PROXY_LOCAL_MCP_URL=http://localhost:8147/mcp
`;
        
        fs.writeFileSync(envPath, envContent + newConfig);
        console.log(`${colors.success}‚úÖ Credentials saved to ${envPath}${colors.reset}`);
        console.log('');
      }
      
      console.log(`${colors.success}‚úÖ Route: ${colors.prompt}${route}${colors.reset}`);
      console.log(`${colors.success}‚úÖ Secret: ${colors.prompt}${secret}${colors.reset}`);
      console.log('');
      
      // Determine proxy URL (production vs development)
      const proxyUrl = args.includes('--local') 
        ? 'wss://localhost:9025/bp/connect'
        : 'wss://hub.m.agifor.me:9025/bp/connect';
      
      const openApiUrl = args.includes('--local')
        ? 'https://localhost:9025/bp/openapi.json'  
        : 'https://hub.m.agifor.me/bp/openapi.json';
      
      // Test connection to Brain Proxy
      console.log(`${colors.system}Testing connection to BrainCloud...${colors.reset}`);
      
      const WebSocket = require('ws');
      const testUrl = `${proxyUrl}?route=${encodeURIComponent(route)}&token=${encodeURIComponent(secret)}`;
      
      const ws = new WebSocket(testUrl);
      let connectionTestComplete = false;
      
      // Set a timeout for the connection test
      const testTimeout = setTimeout(() => {
        if (!connectionTestComplete) {
          connectionTestComplete = true;
          console.log(`${colors.warning}‚ö†Ô∏è Connection test timed out (proxy may be offline)${colors.reset}`);
          ws.terminate();
          showConfiguration();
        }
      }, 10000); // 10 second timeout
      
      ws.on('open', () => {
        if (!connectionTestComplete) {
          connectionTestComplete = true;
          clearTimeout(testTimeout);
          console.log(`${colors.success}‚úÖ Connected to ${proxyUrl}${colors.reset}`);
          ws.close(1000, 'Registration test complete');
          showConfiguration();
        }
      });
      
      ws.on('error', (error) => {
        if (!connectionTestComplete) {
          connectionTestComplete = true;
          clearTimeout(testTimeout);
          console.log(`${colors.warning}‚ö†Ô∏è Connection failed: ${error.message}${colors.reset}`);
          console.log(`${colors.hint}üí° This may be normal if BrainCloud is offline${colors.reset}`);
          showConfiguration();
        }
      });
      
      function showConfiguration() {
        console.log('');
        
        // Create composite API key with route:secret format
        const compositeApiKey = `${route}:${secret}`;
        
        console.log(`${colors.success}To connect ChatGPT:${colors.reset}`);
        console.log(`1. Go to ChatGPT ‚Üí Create GPT ‚Üí Configure`);
        console.log(`2. Add action with URL: ${colors.prompt}${openApiUrl}${colors.reset}`);
        console.log(`3. Add authentication: ${colors.prompt}Bearer ${compositeApiKey}${colors.reset}`);
        console.log(`   ${colors.hint}(This includes both your route and secret)${colors.reset}`);
        console.log(`4. Save and test with "${colors.prompt}magi status${colors.reset}"`);
        console.log('');
        
        const mcpUrl = args.includes('--local')
          ? 'https://localhost/bp/mcp'
          : 'https://hub.m.agifor.me/bp/mcp';
        
        console.log(`${colors.success}To connect Claude.ai:${colors.reset}`);
        console.log(`${colors.warning}‚ö†Ô∏è MCP connectors require Claude for Work (Enterprise)${colors.reset}`);
        console.log('');
        // Generate today's auth code
        const crypto = require('crypto');
        const today = new Date().toISOString().split('T')[0];
        const authCode = crypto.createHash('sha256')
          .update(`${route}:${secret}:${today}`)
          .digest('hex')
          .substring(0, 6)
          .toUpperCase();
        
        console.log(`${colors.info}Plan B - Daily Auth Code Method:${colors.reset}`);
        console.log(`1. Run ${colors.prompt}magi status${colors.reset} to get today's auth code`);
        console.log(`2. Today's code: ${colors.prompt}${authCode}${colors.reset}`);
        console.log(`3. Add Custom Connector in Claude.ai:`);
        console.log(`   - URL: ${colors.prompt}https://hub.m.agifor.me/bp/claude-api.json${colors.reset}`);
        console.log(`   - No authentication required`);
        console.log(`4. In Claude.ai, start with: ${colors.prompt}"magi auth ${authCode}"${colors.reset}`);
        console.log(`5. Then use: ${colors.prompt}"magi search [query]"${colors.reset} etc.`);
        console.log('');
        console.log(`${colors.hint}üí° Code changes daily at midnight${colors.reset}`);
        
        // Only show restart hint if credentials were new or reset
        if (!usingExisting) {
          console.log(`${colors.hint}üí° Restart BrainBridge to load new credentials: ${colors.prompt}magi restart${colors.reset}`);
        }
      }
      
    } catch (error) {
      console.log(`${colors.error}‚ùå Registration failed: ${error.message}${colors.reset}`);
      console.log(`${colors.hint}üí° Make sure Node.js crypto module is available${colors.reset}`);
      process.exit(1);
    }
    break;
    
  default:
    // Default behavior: Launch interactive REPL
    console.log(`${colors.info}üßô Launching MAGI Interactive Mode...${colors.reset}`);
    const replScript = path.join(__dirname, '../dev/scripts/magi-repl.js');
    
    try {
      spawn('node', [replScript], { stdio: 'inherit' });
    } catch (error) {
      console.log(`${colors.error}‚ùå Failed to start REPL: ${error.message}${colors.reset}`);
      
      // Fallback to old behavior  
      if (isBrainBridgeRunning()) {
        console.log(`${colors.success}üßô BrainBridge is running${colors.reset}`);
        console.log(`${colors.hint}üí° Commands: ${colors.prompt}magi logs${colors.reset} ${colors.hint}(stream logs) | ${colors.prompt}magi status${colors.reset} ${colors.hint}(full status)${colors.reset}`);
      } else {
        console.log(`${colors.warning}üßô BrainBridge is down${colors.reset}`);
        console.log(`${colors.hint}üí° Start it with: ${colors.prompt}magi start${colors.reset} ${colors.hint}in another window${colors.reset}`);
        console.log(`${colors.hint}Or run: ${colors.prompt}magi status${colors.reset} ${colors.hint}to check system health${colors.reset}`);
      }
    }
    break;
}